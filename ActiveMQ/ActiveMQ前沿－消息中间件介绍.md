# 消息中间件概述

​	随着互联网技术的不断发展,从RPC到Web Service,从SOA的推行再到RESTful以及云计算中PaaS与SaaS的推广,分布式架构在互联网企业中得到了广泛应用,消息中间件则在分布式系统之间的**通信**、**集成**和**整合**上发挥了关键作用。分布式消息中间件通过**高效、可靠的消息传递机制**,<u>降低应用系统之间的耦合性,实现高性能的数据交换,保障了分布式计算网络环境下高可用和一致性。</u>

​	消息中间件已经逐渐成为企业IT系统内部通信的核心手段,是分布式系统中重要的组件。它具有**低耦合、可靠投递、广播、流量控制、最终一致性**等一系列功能，成为异步RPC的主要手段之一，**主要解决应用解耦、异步消息、流量削峰等问题，实现高性能、高可用、可伸缩和最终一致性**。当今市面上有很多主流的消息中间件,如老牌的ActiveMQ、RabbitMQ,炙手可热的Kafka,阿里巴巴自主开发RocketMQ等。

# 消息中间件应用场景

​	常用的使用场景： **异步处理、应用解耦、流量削峰、消息通信**。

## 异步处理

**场景说明**：用户注册后，需要发送注册邮件和注册短信。

**传统做法有两种**：串行方式、并行方式。

* 串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。
  ![](http://ww2.sinaimg.cn/large/006tNc79gy1g3b6pduad6j310s09i415.jpg)

  ```shell
  串行问题：
  1、必须先完成前面的任务，才能执行后面的任务；
  2、中间节点任务的延时会导致整体响应的延时。
  ```

* 并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务全部完成后，返回给客户端。与串行的差别在于，并行的方式可以提高服务响应时效。
  ![](http://ww1.sinaimg.cn/large/006tNc79gy1g3b6vlublgj30sa0f6782.jpg)

  ​	假设三个业务节点每个使用50毫秒钟,不考虑网络等其他开销,则串行方式的时间是150毫秒,并行的时间可能是100毫秒。 因为CPU在单位时间内处理的请求数是一定的,假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次(1000/150)。并行方式处理的请求量是10次(1000/100) 小结:如以上案例描述,传统的方式系统的性能(并发量,吞吐量,响应时间)会有瓶颈。如何解决这个问题呢?
  ​	引入消息队列，将非必需的业务逻辑异步处理。改造后：

  ![](http://ww1.sinaimg.cn/large/006tNc79gy1g3b7jfz9j2j314e0dijw9.jpg)	按照以上约定,用户的响应时间相当于是注册信息写入数据库的时间,也就是50毫秒。注册邮件,发送短信写入消息队列后,直接返回,因此写入消息队列的速度很快,基本可以忽略,因此用户的响应时间可能是50毫秒。因此架构改变后,系统的吞吐量提高到每秒20 QPS。比串行提高了3倍,比并行提高了两倍

## 应用解耦

**场景说明**：用户下单后，订单系统需要通知库存系统。

**传统做法**：订单系统直接调用库存系统接口。如图：

![](http://ww2.sinaimg.cn/large/006tNc79gy1g3b7pglb11j30km07y3zm.jpg)

​	**传统模式缺点**：假如库存系统无法访问，则订单减库存失败，从而导致订单失败，这样的话，订单系统和库存系统耦合紧密。

​	如何解耦？引入消息队列，如图：

![](http://ww1.sinaimg.cn/large/006tNc79gy1g3b7wkrs25j30om0cq0uu.jpg)

​	**订单系统**：用户下单，订单系统完成持久化处理，并将下单消息写入消息队列，返回用户下单成功；

​	**库存系统**：订阅下单消息，采用拉／推的方式消费下单消息，进行库存操作。

​	即使，在下单时库存系统不能正常使用，也不影像用户正常下单。因为，下单后，订单消息写入消息队列后就默认下单成功了。后续库存系统直接消费下单消息完成库存操作即可。从而，实现了订单系统和库存系统的应用解耦。

## 流量削峰

**应用场景**：一般在秒杀或团抢活动中应用广泛。秒杀活动，一般会因为流量过大，导致流量暴涨，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。

* 可以控制活动人数
* 可以缓解短时间内高流量压垮应用
  ![](http://ww2.sinaimg.cn/large/006tNc79gy1g3bbw0aozuj30uw084mzs.jpg)
  用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。秒杀业务根据消息队列中的请求消息，继续做后续处理。

## 日志处理

​	日志处理是指将消息队列用在日志处理中，比如kafka的应用，解决大量日志传输的问题。架构简化如下：

![](http://ww4.sinaimg.cn/large/006tNc79gy1g3bc2k4nh2j30wc07uq4u.jpg)

​	日志采集客户端，负责日志数据采集，定时写入到kafka消息队列，消息队列负责日志数据的接收、存储和转发。日志处理应用订阅并消费kafka队列中的日志数据。

## 消息通信

​	消息通讯：消息队列一般都内置了高效的通信机制,因此也可以用在纯的消息通讯。比如实现**点对点消息队列**,或者**聊天室**等。

* 点对点通讯：
  ![](http://ww3.sinaimg.cn/large/006tNc79gy1g3bcbydvd2j30sw080jt2.jpg)
  客户A、B使用同一队列，进行消息通讯。
* 聊天室通讯：
  ![](http://ww1.sinaimg.cn/large/006tNc79gy1g3bcd7k1i1j30sw08imzu.jpg)
  客户端A,客户端B,客户端N订阅同一主题,进行消息发布和接收。实现类似聊天室效果。以上实际是消息队列的两种消息模式,点对点或发布订阅模式。模型为示意图,供参考。

# 消息中间件业务示例

## 电商系统

![](http://ww2.sinaimg.cn/large/006tNc79gy1g3bchxrs2gj30vk0bwteq.jpg)

​	消息队列采用高可用、可持久化的消息中间件。比如ActiveMQ、RabbitMQ、RocketMQ。

1. 应用将主干业务处理完成后，写入消息队列（应用收到消息队列接收成功反馈后，再返回，这样保障消息的完整性，消息发送是否成功可以开启消息的确认模式）。
2. 扩展流程(如发短信、配送处理)订阅队列消息。采用推或拉的方式来消费消息。
3. 通过消息队列解耦会带来数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用消费消息，并结合数据库方式实现基于消息队列的后续处

## 日志收集系统

![](http://ww4.sinaimg.cn/large/006tNc79gy1g3bd8tdhptj31440ectgo.jpg)

​	日志收集系统，分为Zookeeper注册中心、日志收集客户端、kafka集群和Storm集群(OtherApp)四部分组成。

* **Zookeeper注册中心**：提供负载均衡和地址查找服务；
* **日志收集客户端**：用于采集应用系统的日志,并将数据推送到kafka队列；
* **Kafka集群**：接收,路由,存储,转发等消息处理；
* **Storm集群**：与OtherApp处于同一级别,采用拉的方式消费队列中的数据；

# 消息中间件的组成

* **Broker**：消息服务器,作为server提供消息核心服务 
* **Producer**：消息生产者,业务的发起方,负责生产消息传输给broker
* **Consumer**：消息消费者,业务的处理方,负责从broker获取消息并进行业务逻辑处理；
* **Topic**：主题,发布订阅模式下的消息统一汇集地,不同生产者向topic发送消息,由MQ服务器分发到不同的订阅者,实现消息的广播；
* **Queue**：队列,PTP（点对点）模式下,特定生产者向特定queue发送消息,消费者订阅特定的queue完成指定消息的接收
* **Message**：消息体,根据不同通信协议定义的固定格式进行编码的数据包,来封装业务数据,实现消息的传输

# 消息中间件模式分类

## 点对点

PTP点对点:使用queue作为通信载体

![](http://ww4.sinaimg.cn/large/006tNc79gy1g3bduj0olbj31c40skqjg.jpg)

> 1. 消息生产者生产消息发送到queue中,然后消息消费者从queue中取出并且消费消息；
> 2. 消息被消费以后,queue中不再存储,所以消息消费者不可能消费到已经被消费的消息；
> 3. Queue支持存在多个消费者，实现了负载均衡，但是对一个消息而言,只会有一个消费者可以消费。当没有消费者可用时,这个消息会被保存直到有一个可用的消费者。

## 发布／订阅

Pub/Sub发布订阅(广播)：使用topic作为通信载体

![](http://ww4.sinaimg.cn/large/006tNc79gy1g3bdya5o9zj31b20suwys.jpg)

> 1. 消息生产者(发布)将消息发布到topic中,同时有多个消息消费者(订阅)消费该消息。和点对点方式不
>    同,发布到topic的消息会被所有订阅者消费；
> 2. queue实现了负载均衡,将producer生产的消息发送到消息队列中,由多个消费者消费。但一个消息只能被一个消费者接受,当没有消费者可用时,这个消息会被保存直到有一个可用的消费者；
> 3. topic实现了发布和订阅,当你发布一个消息,所有订阅这个topic的服务都能得到这个消息,所以从1到N个
>    订阅者都能得到一个消息的拷贝。

# 消息中间件常用的应用协议

## AMQP协议

> ​	AMQP即`Advanced Message Queuing Protocol`,一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息,并不受客户端/中间件不同产品及不同开发语言等条件的限制。
>
> 优点：可靠、通用
>
> RabbitMQ是AMQP协议的标准实现。
> JMS（java消息服务）比AMQP协议诞生的要早

## MQTT协议

> ​	MQTT(`Message Queuing Telemetry Transport`,消息队列遥测传输)是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台,几乎可以把所有联网物品和外部连接起来,被用来当做传感器和致动器(比如通过Twitter让房屋联网)的 。 
>
> 优点:格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统 

## STOMP协议

> ​	STOMP(`Streaming Text Orientated Message Protocol`),是一种为MOM(`Message Oriented Middleware`,面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式,允许客户端与任意STOMP消息代理(Broker)进行交互。 
>
> 优点:命令模式(非topic\queue模式) 

## XMPP协议

> ​	XMPP(可扩展消息处理现场协议,`Extensible Messaging and Presence Protocol`)是基于可扩展标记语言(XML)的协议，多用于即时消息(IM)以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息,即使其操作系统和浏览器不同。
>
> 优点：通用公开、兼容性强、可扩展、安全性高,但XML编码格式占用带宽大

## 其他基于TCP／IP自定义协议

> ​	有些特殊框架(如:redis、kafka、zeroMq等)根据自身需要未严格遵循MQ规范,而是基于TCP\IP自行封装了一套协议,通过网络socket接口进行传输,实现了MQ的功能。

# 常见消息中间件介绍

## ActiveMQ

​	Apache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,少量代码就可以高效

地实现高级应用场景。

主要特点：

1. 多种语言和协议编写客户端。语言: , C, C++, C#, Ruby, Perl, Python, PHP。 

2. 多种应用协议: OpenWire,Stomp 、REST,WS Notification,XMPP,AMQP 

3. 可插拔的传输协议支持,如:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA 

4. 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务) 

5. ,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性 

6. 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 

   resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上 

7. 支持通过JDBC和journal提供高速的消息持久化 

8. 从设计上保证了高性能的集群 

9. 支持Ajax 

10. 支持与Axis的整合

11. 可以很容易得调用内嵌JMS provider,进行测试 

## RabbitMQ

​	2007年,基于AMQP标准的RabbitMQ 1.0版本由Rabbit技术公司发布,2010年被SpringSource收购,2013年并入 Pivotal,现由Pivotal Software提供商业支持。RabbitMQ是一种基于 实现AMQP协议的开源消息中间件, 它提供了功能强大的消息队列服务,常用于Web服务器快速响应请求,适合跨平台、跨语言的消息传输。 

​	RabbitMQ具有消息可靠传输、灵活路由策略、多协议支持等特点。RabbitMQ具有健壮的消息确认机制、用户角色体系、以及认证和授权管理功能,保障消息可靠传输。灵活的交换器和绑定规则设置提供了强大的消息路由功能,同时支持AMQP、HTTP、STOMP、MQTT等协议。此外,RabbitMQ多节点集群的联合不依赖外部服务,支持服务的高可用, 但服务的负载均衡需要使用第三方组件。 

## Kafka

​	Kafka是由LinkedIn公司在2010年12月开源的一种高吞吐量的分布式消息系统,属于Apache软件基金会的顶级子项 目之一,目前已被越来越多的开源分布式处理系统集成。Kafka适用于大规模消息处理的应用场景,具有良好的可扩 展性和性能优势。与传统消息系统不同,Kafka还被广泛应用于日志聚合、流式数据处理等场景中。 

​	Kafka具有高性能、高可用、分布式的技术特点。Kafka强大的负载均衡和副本策略保证了节点的可靠性和高可用 性,支持节点的动态扩展;在设计实现上与传统消息中间件有较大差异,使用文件系统来管理消息的生命周期,能够 在常数时间复杂度内提供消息持久化和数据访问,支持消息的批量发送和压缩传输,性能表现优异。由于其并非作为 传统MQ设计,没有遵循主流消息服务规范,因此在事务、协议兼容等方面有所欠缺。 

Kafka是是用scala实现的一个高性能分布式Publish／Subscribe消息队列系统，具有以下特性：

* 快速持久化：通过磁盘顺序读写与零拷贝机制,可以在O(1)的系统开销下进行消息持久化;
* 高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率;
* 高堆积：支持topic下消费者较长时间离线,消息堆积量大;
* 完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式,依赖zookeeper自动实现复杂均衡;
* 支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统,但又要求实时处理的限制,这是
  一个可行的解决方案。
* 不完全符合jms规范,注重吞吐量,类似udp 和 tcp
* 量大对数据不是百分之百保证的,会有数据丢失,不是百分之百送达 (amq和rmq等有重发机制，而kafka没有);在吞吐量有提升 ,在这方面就得有牺牲, 所以**kafka适合大数据量流转, 比如日志数据、用作统计的数据**。 

## RocketMQ

​	阿里系下开源的一款分布式、队列模型的消息中间件,原名Metaq,3.0版本名称改为 ,是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品(Notify、metaq)进行整合,只维护核心功能,去除了所有其他运行时依赖,保证核心功能最简化,在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构,目前主要多用于订单交易。具有以下特点：

* 能够保证严格的消息顺序
* 提供针对消息的过滤功能
* 提供丰富的消息拉取模式
* 高效的订阅者水平扩展能力
* 实时的消息订阅机制
* 亿级消息堆积能力

官方提供了一些[不同于kafka的对比差异](https://rocketmq.apache.org/docs/motivation/)

​	RocketMQ 是一款开源的分布式消息系统,基于高可用分布式集群技术,提供低延时的、高可靠的消息发布与订阅服务。同时,广泛应用于多个领域,包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。

## Redis

​	使用C语言开发的一个Key-Value的NoSQL数据库,开发维护很活跃, 虽然它是一个key-value数据库存储系统，但它本身支持MQ功能，所以完全可以当作一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作, 各执行100万次,每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明:入队时,当数据比较小时Redis的性能要高于RabbitMQ,而如果数据大小超过了10K,Redis则慢的无法忍受;出队时,无论数据大小,Redis都表现出非常好的性能,而RabbitMQ的出队性能则远低于Redis。 

> redis的lpush、rpop/brpop命令完成了消息队列的作用。 redis只适合小消息的处理。
>
> redis没有信息中间件的一些特点: 
>
> * 重复消费
> * 可靠性消息机制
> * 消息确认

## ZeroMQ

​	号称最快的消息队列系统，专门为高吞吐量／低延迟的场景开发，在金融界应用广泛，偏重于实时通信场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列,但是开发人员需要自己组合多种技术框架,开发成本高。因此ZeroMQ具有一个独特的非中间件的模式,更像一个socket library,你不需要安装和运行一个消息服务器或中间件,因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。但是ZeroMQ仅提供非持久性的队列, 如果down机,数据将会丢失。如:Twitter的Storm中使用ZeroMQ作为数据流的传输。 

​	ZeroMQ套接字是与传输层无关的:ZeroMQ套接字对所有传输层协议定义了统一的API接口。默认支持进程内（inproc） 、进程间（IPC） 、多播、TCP协议,在不同的协议之间切换只要简单的改变连接字符串的前缀。可以在任何时候以最小的代价从进程间的本地通信切换到分布式下的TCP通信。ZeroMQ在背后处理连接建立,断开和重连逻辑。

* 无锁的队列模型:对于跨线程间的交互(用户端和session)之间的数据交换通道pipe,采用无锁的队列算法CAS;在pipe的两端注册有异步事件,在读或者写消息到pipe的时,会自动触发读写事件。
* 批量处理的算法:对于批量的消息,进行了适应性的优化,可以批量的接收和发送消息。
* 多核下的线程绑定,无须CPU切换:区别于传统的多线程并发模式,信号量或者临界区,zeroMQ充分利用多核
  的优势,每个核绑定运行一个工作者线程,避免多线程之间的CPU切换开销。

## 总结



主流消息中间件对比

常见消息中间件问题